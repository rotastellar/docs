---
title: Rust SDK
description: "Official Rust SDK for the RotaStellar API"
---

# Rust SDK

The official Rust SDK for RotaStellar, providing type-safe access to Planning, Intelligence, and Runtime APIs.

<Info>
  **Status:** Early Access — [Request API key](https://rotastellar.com/early-access/)
</Info>

## Installation

Add to your `Cargo.toml`:

```toml
[dependencies]
rotastellar = "0.1"
tokio = { version = "1", features = ["full"] }
```

Or use cargo:

```bash
cargo add rotastellar
cargo add tokio --features full
```

### Feature Flags

```toml
[dependencies]
rotastellar = { version = "0.1", features = ["rustls"] }

# Available features:
# - rustls: Use rustls instead of native-tls (default)
# - native-tls: Use native TLS
# - blocking: Enable blocking client
```

## Quick Start

```rust
use rotastellar::RotaStellarClient;

#[tokio::main]
async fn main() -> Result<(), Box<dyn std::error::Error>> {
    // Initialize client
    let client = RotaStellarClient::new("rs_your_api_key")?;

    // Or from environment variable
    // export ROTASTELLAR_API_KEY=rs_your_api_key
    let client = RotaStellarClient::from_env()?;

    // Track a satellite
    let iss = client.get_satellite("25544").await?;
    println!("ISS: {}, {}", iss.position.lat, iss.position.lon);

    Ok(())
}
```

## Client Configuration

```rust
use rotastellar::{RotaStellarClient, Config};
use std::time::Duration;

let config = Config::builder()
    .api_key("rs_...")
    .base_url("https://api.rotastellar.com/v1")
    .timeout(Duration::from_secs(30))
    .max_retries(3)
    .build()?;

let client = RotaStellarClient::with_config(config)?;
```

## Intelligence API

### Get Satellite

```rust
use rotastellar::RotaStellarClient;

#[tokio::main]
async fn main() -> Result<(), Box<dyn std::error::Error>> {
    let client = RotaStellarClient::new("rs_...")?;

    // Get satellite by NORAD ID
    let sat = client.get_satellite("25544").await?; // ISS
    println!("Name: {}", sat.name);
    println!("Position: {}, {}", sat.position.lat, sat.position.lon);
    println!("Altitude: {} km", sat.position.altitude_km);

    // Get position only
    let pos = client.get_satellite_position("25544", None).await?;
    println!("Velocity: {} km/s", pos.velocity_km_s);

    Ok(())
}
```

### List Satellites

```rust
// List satellites with filters
let satellites = client.list_satellites()
    .constellation("Starlink")
    .limit(100)
    .send()
    .await?;

for sat in satellites {
    println!("{}: {}", sat.name, sat.norad_id);
}

// Filter by operator
let spacex_sats = client.list_satellites()
    .operator("SpaceX")
    .limit(50)
    .send()
    .await?;
```

### Conjunction Analysis

```rust
use chrono::{Utc, Duration};

// Get conjunction risks
let conjunctions = client.list_conjunctions()
    .satellite_id("25544")
    .threshold_km(5.0)
    .limit(10)
    .send()
    .await?;

for conj in conjunctions {
    println!("TCA: {}", conj.tca);
    println!("Miss distance: {:.3} km", conj.miss_distance_km);
    println!("Probability: {:.2e}", conj.collision_probability);
}
```

### Pattern Detection

```rust
// Detect maneuvers and anomalies
let patterns = client.list_patterns()
    .satellite_id("44832") // COSMOS-2542
    .lookback_days(30)
    .send()
    .await?;

for pattern in patterns {
    println!("{}: {}", pattern.pattern_type, pattern.description);
    println!("Confidence: {:.1}%", pattern.confidence * 100.0);
}
```

### Trajectory Prediction

```rust
use chrono::{Utc, Duration};

// Get predicted trajectory
let trajectory = client.get_trajectory()
    .satellite_id("25544")
    .start(Utc::now())
    .end(Utc::now() + Duration::hours(2))
    .interval_sec(60)
    .send()
    .await?;

for point in trajectory {
    println!("{}: {:.2}, {:.2}", point.timestamp, point.lat, point.lon);
}
```

## Planning API

### Feasibility Analysis

```rust
use rotastellar::planning::AnalyzeRequest;

// Analyze if orbital compute is viable
let result = client.analyze_feasibility(AnalyzeRequest {
    workload_type: "inference".to_string(),
    compute_tflops: 10.0,
    data_gb: 1.5,
    latency_requirement_ms: Some(100.0),
    orbit_altitude_km: 550.0,
}).await?;

println!("Feasible: {}", result.feasible);
println!("Recommendation: {}", result.recommendation);
```

### Thermal Simulation

```rust
use rotastellar::planning::ThermalRequest;

// Model heat rejection in orbit
let thermal = client.simulate_thermal(ThermalRequest {
    power_watts: 500.0,
    orbit_altitude_km: 550.0,
    radiator_area_m2: 2.0,
    duration_hours: 24.0,
}).await?;

println!("Max temp: {}°C", thermal.max_temperature_c);
println!("Min temp: {}°C", thermal.min_temperature_c);
```

### Latency Simulation

```rust
use rotastellar::types::Position;
use rotastellar::planning::LatencyRequest;

// Model end-to-end latency
let source = Position::new(37.7749, -122.4194); // San Francisco
let dest = Position::new(51.5074, -0.1278);     // London

let latency = client.simulate_latency(LatencyRequest {
    source,
    destination: dest,
    orbit_altitude_km: 550.0,
    relay_count: 2,
}).await?;

println!("Total latency: {:.1} ms", latency.total_latency_ms);
```

## Runtime API (Coming Q2 2026)

```rust
use rotastellar::runtime::{JobRequest, Constraints};

// Submit inference job
let job = client.submit_job(JobRequest {
    model: "llama-70b".to_string(),
    prompt: "...".to_string(),
    constraints: Constraints {
        latency_sla_ms: Some(200),
        energy_budget_wh: Some(0.5),
    },
}).await?;

// Get result
let result = client.get_job_result(&job.id, 30).await?;
println!("Response: {}", result.text);
```

## Pagination

Handle large result sets:

```rust
// Manual pagination
let mut page = client.list_satellites()
    .constellation("Starlink")
    .limit(100)
    .send()
    .await?;

loop {
    for sat in &page.items {
        println!("{}", sat.name);
    }

    if page.has_more {
        page = page.next_page().await?;
    } else {
        break;
    }
}
```

## Error Handling

```rust
use rotastellar::RotaStellarClient;
use rotastellar::error::{Error, ApiError};

#[tokio::main]
async fn main() -> Result<(), Box<dyn std::error::Error>> {
    let client = RotaStellarClient::new("rs_...")?;

    match client.get_satellite("INVALID-ID").await {
        Ok(sat) => println!("Found: {}", sat.name),
        Err(Error::NotFound(msg)) => println!("Not found: {}", msg),
        Err(Error::RateLimit { retry_after }) => {
            println!("Rate limited. Retry after {}s", retry_after);
        }
        Err(Error::Authentication(msg)) => println!("Auth error: {}", msg),
        Err(Error::Validation(msg)) => println!("Invalid request: {}", msg),
        Err(Error::Api(ApiError { code, message })) => {
            println!("API error {}: {}", code, message);
        }
        Err(e) => println!("Other error: {}", e),
    }

    Ok(())
}
```

## Blocking Client

For non-async contexts:

```rust
use rotastellar::blocking::RotaStellarClient;

fn main() -> Result<(), Box<dyn std::error::Error>> {
    let client = RotaStellarClient::new("rs_...")?;

    let iss = client.get_satellite("25544")?;
    println!("ISS: {}, {}", iss.position.lat, iss.position.lon);

    Ok(())
}
```

## Distributed Compute API (Coming Q1 2026)

The `rotastellar-distributed` crate enables Earth-space AI coordination:

```bash
cargo add rotastellar-distributed
```

### Federated Learning

```rust
use rotastellar_distributed::{FederatedClient, CompressionConfig, CompressionMethod};

#[tokio::main]
async fn main() -> Result<(), Box<dyn std::error::Error>> {
    // Configure gradient compression (100x reduction)
    let compression = CompressionConfig::new()
        .method(CompressionMethod::TopKQuantized)
        .k_ratio(0.01)
        .quantization_bits(8)
        .error_feedback(true);

    // Initialize client on orbital node
    let client = FederatedClient::builder()
        .api_key("rs_...")
        .node_id("orbital-3")
        .node_type("orbital")
        .compression(compression)
        .build()?;

    // Sync during ground pass
    client.sync(&gradients, "high").await?;

    Ok(())
}
```

<Info>
  See the [Distributed Compute documentation](/distributed/overview) for full API reference.
</Info>

## Type Definitions

All types are fully documented:

```rust
use rotastellar::types::{Position, Orbit, Satellite};

let sat = client.get_satellite("25544").await?;

// All fields are strongly typed
let lat: f64 = sat.position.lat;
let lon: f64 = sat.position.lon;
let altitude_km: f64 = sat.position.altitude_km;
let velocity_km_s: f64 = sat.position.velocity_km_s;
```

## Source Code

<CardGroup cols={2}>
  <Card title="GitHub Repository" icon="github" href="https://github.com/rotastellar/rotastellar-rust">
    View source, report issues, and contribute.
  </Card>
  <Card title="crates.io" icon="rust" href="https://crates.io/crates/rotastellar">
    Package page and version history.
  </Card>
</CardGroup>
