---
title: Space Mesh
description: "ISL routing for orbital node communication"
---

# Space Mesh

<Warning>
  **Coming Q1 2026** — This feature is in development.
  [Request early access](https://rotastellar.com/developers) to be notified when available.
</Warning>

## Overview

Space Mesh enables communication between orbital nodes via Inter-Satellite Links (ISL). When direct ground contact isn't available, data can be routed through neighboring satellites to reach a ground station.

## Key Components

<CardGroup cols={2}>
  <Card title="SpaceMesh" icon="diagram-project">
    ISL network topology manager
  </Card>
  <Card title="Route" icon="route">
    Path between source and destination
  </Card>
  <Card title="Node" icon="satellite">
    Orbital node with ISL capability
  </Card>
  <Card title="Link" icon="link">
    ISL connection between nodes
  </Card>
</CardGroup>

## Why ISL Routing?

Without ISL, each orbital node must wait for its own ground pass. With ISL, data can relay through neighboring satellites:

<Tabs>
  <Tab title="Without ISL">
    Each satellite waits independently for ground contact. Long gaps between sync opportunities.

    | Satellite | Sync Pattern |
    |-----------|--------------|
    | Sat-1 | Sync - Wait 90min - Sync - Wait 90min |
    | Sat-2 | Wait 30min - Sync - Wait 90min - Sync |
    | Sat-3 | Wait 60min - Sync - Wait 90min - Sync |
  </Tab>
  <Tab title="With ISL">
    Any satellite can relay through neighbors to reach ground. Continuous sync capability.

    **Example route:** Sat-1 → Sat-2 → Sat-3 → Ground Station

    All nodes can sync continuously via mesh routing.
  </Tab>
</Tabs>

## Mesh Topology

### Constellation Layout

The mesh connects orbital nodes via high-bandwidth Inter-Satellite Links (ISL):

<CardGroup cols={2}>
  <Card title="Orbital Layer" icon="satellite">
    **Sat-1, Sat-2, Sat-3, Sat-4** in LEO orbit, connected via 10 Gbps optical ISL links
  </Card>
  <Card title="Ground Layer" icon="tower-broadcast">
    Ground stations receive data from any satellite with line-of-sight
  </Card>
</CardGroup>

| Link Type | Bandwidth | Latency |
|-----------|-----------|---------|
| ISL (satellite to satellite) | 10 Gbps | 3-15 ms |
| Downlink (satellite to ground) | 1 Gbps | 5-25 ms |
| Uplink (ground to satellite) | 100-500 Mbps | 5-25 ms |

## Basic Usage

<CodeGroup>
```python Python
from rotastellar_distributed import SpaceMesh

# Initialize mesh
mesh = SpaceMesh(api_key="rs_...")

# Add orbital nodes
mesh.add_node("sat-1", orbit_alt=550, isl_range=5000)
mesh.add_node("sat-2", orbit_alt=550, isl_range=5000)
mesh.add_node("sat-3", orbit_alt=550, isl_range=5000)
mesh.add_node("sat-4", orbit_alt=550, isl_range=5000)

# Add ground stations
mesh.add_ground_station("svalbard", lat=78.2, lon=15.6)
mesh.add_ground_station("singapore", lat=1.3, lon=103.8)

# Find route
route = mesh.find_route(
    source="sat-1",
    destination="ground-svalbard",
    data_size=100e6,       # 100 MB
    max_hops=3
)

print(f"Path: {' → '.join(route.path)}")
print(f"Hops: {route.num_hops}")
print(f"Total latency: {route.latency_ms:.1f} ms")
print(f"Bottleneck: {route.bottleneck_link}")
print(f"Available bandwidth: {route.bandwidth / 1e6:.0f} Mbps")
```

```typescript Node.js
import { SpaceMesh } from '@rotastellar/distributed';

const mesh = new SpaceMesh({ apiKey: 'rs_...' });

mesh.addNode('sat-1', { orbitAlt: 550, islRange: 5000 });
mesh.addNode('sat-2', { orbitAlt: 550, islRange: 5000 });
mesh.addNode('sat-3', { orbitAlt: 550, islRange: 5000 });

mesh.addGroundStation('svalbard', { lat: 78.2, lon: 15.6 });

const route = await mesh.findRoute({
  source: 'sat-1',
  destination: 'ground-svalbard',
  dataSize: 100e6,
  maxHops: 3
});

console.log(`Path: ${route.path.join(' → ')}`);
console.log(`Latency: ${route.latencyMs} ms`);
```

```rust Rust
use rotastellar_distributed::SpaceMesh;

let mut mesh = SpaceMesh::new();

mesh.add_node("sat-1", 550.0, 5000.0);
mesh.add_node("sat-2", 550.0, 5000.0);
mesh.add_node("sat-3", 550.0, 5000.0);

mesh.add_ground_station("svalbard", 78.2, 15.6);

let route = mesh.find_route("sat-1", "ground-svalbard", 100e6, 3)?;

println!("Path: {:?}", route.path());
println!("Latency: {} ms", route.latency_ms());
```
</CodeGroup>

## Link Configuration

Configure ISL characteristics:

```python
# Add node with detailed ISL config
mesh.add_node(
    "sat-1",
    orbit_alt=550,                # km
    orbit_inc=53,                 # degrees inclination
    isl_config={
        "range_km": 5000,         # Max ISL range
        "bandwidth": 10e9,        # 10 Gbps
        "latency_per_km": 0.003,  # ms per km
        "max_connections": 4,     # Max simultaneous links
        "optical": True           # Optical vs RF
    }
)

# View current links
links = mesh.get_links("sat-1")
for link in links:
    print(f"{link.source} ↔ {link.target}")
    print(f"  Distance: {link.distance_km:.0f} km")
    print(f"  Bandwidth: {link.bandwidth / 1e9:.0f} Gbps")
    print(f"  Latency: {link.latency_ms:.1f} ms")
    print(f"  Status: {link.status}")
```

## Routing Algorithms

| Algorithm | Description | Best For |
|-----------|-------------|----------|
| `shortest_path` | Minimum hops | Low latency |
| `max_bandwidth` | Highest capacity path | Large transfers |
| `min_latency` | Lowest total delay | Real-time |
| `load_balanced` | Distribute across paths | High utilization |

```python
# Shortest path (default)
route = mesh.find_route(source, dest, algorithm="shortest_path")

# Maximum bandwidth
route = mesh.find_route(source, dest, algorithm="max_bandwidth")

# Minimum latency
route = mesh.find_route(source, dest, algorithm="min_latency")

# Load balanced
route = mesh.find_route(source, dest, algorithm="load_balanced")
```

## Dynamic Topology

The mesh adapts as satellites move:

```python
# Update positions (typically from TLE)
mesh.update_positions(epoch=datetime.now())

# Or subscribe to position updates
@mesh.on_topology_change
def handle_change(event):
    if event.type == "link_lost":
        print(f"Link lost: {event.source} ↔ {event.target}")
        # Routes using this link are automatically rerouted
    elif event.type == "link_established":
        print(f"New link: {event.source} ↔ {event.target}")

# Get current network state
state = mesh.get_state()
print(f"Active nodes: {state.active_nodes}")
print(f"Active links: {state.active_links}")
print(f"Network diameter: {state.diameter} hops")
print(f"Avg path length: {state.avg_path_length:.1f} hops")
```

## Multi-Path Routing

For reliability, use multiple paths:

```python
# Find multiple disjoint paths
paths = mesh.find_paths(
    source="sat-1",
    destination="ground-svalbard",
    num_paths=3,
    disjoint=True        # No shared links
)

for i, path in enumerate(paths):
    print(f"Path {i+1}: {' → '.join(path.nodes)}")
    print(f"  Bandwidth: {path.bandwidth / 1e6:.0f} Mbps")

# Split data across paths
transfers = mesh.split_transfer(
    data_size=1e9,       # 1 GB
    paths=paths,
    strategy="proportional"  # By bandwidth
)
```

## Traffic Shaping

Manage bandwidth allocation:

```python
# Reserve bandwidth for critical traffic
reservation = mesh.reserve_bandwidth(
    source="sat-1",
    destination="ground-svalbard",
    bandwidth=100e6,     # 100 Mbps
    duration_seconds=300,
    priority="critical"
)

# Monitor traffic
traffic = mesh.get_traffic()
for link in traffic.links:
    print(f"{link.id}: {link.utilization:.1%} utilized")
    print(f"  Current: {link.current_throughput / 1e6:.0f} Mbps")
    print(f"  Peak: {link.peak_throughput / 1e6:.0f} Mbps")
```

## Example: Global Coverage

```python
from rotastellar_distributed import SpaceMesh

# Create mesh for a Walker constellation
mesh = SpaceMesh(api_key="rs_...")

# Add 40 satellites in polar orbit
for plane in range(8):
    for sat in range(5):
        mesh.add_node(
            f"sat-{plane}-{sat}",
            orbit_alt=550,
            orbit_inc=97.5,
            raan=plane * 45,          # Right ascension
            true_anomaly=sat * 72,    # Position in plane
            isl_range=5000
        )

# Add global ground stations
stations = [
    ("svalbard", 78.2, 15.6),
    ("hawaii", 19.8, -155.5),
    ("singapore", 1.3, 103.8),
    ("chile", -33.4, -70.6),
    ("south-africa", -33.9, 18.4),
]
for name, lat, lon in stations:
    mesh.add_ground_station(name, lat, lon)

# Network stats
state = mesh.get_state()
print(f"Satellites: {state.active_nodes}")
print(f"ISL links: {state.active_links}")
print(f"Ground stations: {state.ground_stations}")
print(f"Global coverage: {state.coverage:.1%}")

# Any satellite can reach ground within 2 hops
for sat in mesh.nodes:
    routes = mesh.find_paths(sat, "any-ground", max_hops=2)
    assert len(routes) > 0, f"{sat} has no route to ground!"
```

## Integration with Sync Scheduler

Space Mesh integrates with the Sync Scheduler for optimal routing:

```python
from rotastellar_distributed import SyncScheduler, SpaceMesh

# Initialize both
mesh = SpaceMesh(api_key="rs_...")
scheduler = SyncScheduler(
    api_key="rs_...",
    mesh=mesh              # Enable ISL routing
)

# Schedule sync - will use ISL if direct pass unavailable
sync = scheduler.schedule_sync(
    node="sat-1",
    data_size=100e6,
    priority="critical",
    allow_relay=True       # Allow ISL relay
)

# Sync might go: sat-1 → sat-2 → ground-svalbard
print(f"Route: {' → '.join(sync.route.path)}")
```

## Next Steps

<CardGroup cols={2}>
  <Card title="Sync Scheduler" icon="clock" href="/distributed/sync-scheduler">
    Schedule syncs with mesh routing
  </Card>
  <Card title="Federated Learning" icon="network-wired" href="/distributed/federated-learning">
    Train models across the mesh
  </Card>
</CardGroup>
